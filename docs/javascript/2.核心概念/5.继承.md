# 继承实现

## 1. 最终实现方式（寄生组合式继承）

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.say = function () {
  console.log(`name: ${this.name}, age: ${this.age}`);
};

function Student(name, age, sno) {
  Person.call(this, name, age);

  this.sno = sno;
}

function inherit(subConstructor, superConstructor) {
  subConstructor.prototype = Object.create(superConstructor.prototype, {
    constructor: {
      enumerable: false,
      configurable: true,
      writable: false,
      value: subConstructor,
    },
  });
}

inherit(Student, Person);

Student.prototype.study = function () {
  this.say();
  console.log(`sno: ${this.sno}`);
};

const stu = new Student("张三", 18, 20200912);

console.log(stu); // Student {name: '张三', age: 18, sno: 20200912}

stu.study(); // name: 张三, age: 18 /n sno: 20200912

stu.say(); // name: 张三, age: 18
```

## 2. 继承方式演变过程

### 2.1 原型链继承

将父类的实例赋值给子类构造函数的原型上，实现集成

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.say = function () {
  console.log(`name: ${this.name}, age: ${this.age}`);
};

function Student(sno) {
  this.sno = sno;
}

Student.prototype = new Person("张三", 18);

Student.prototype.study = function () {
  this.say();
  console.log(`sno: ${this.sno}`);
};

const stu = new Student(20200912);

console.log(stu); // Student {sno: 20200912}

stu.study(); // name: 张三, age: 18 /n sno: 20200912

stu.say(); // name: 张三, age: 18
```

缺点：

1.
